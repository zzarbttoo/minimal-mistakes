# Process 

* 이 글은 KOCW에 공개되어있는 '반효경 교수님'의 운영체제 강의 및 강의 교재 Operation System Concepts(a.k.a 공룡책🦕)의 내용을 기반으로 작성했다.

* 이번 챕터에서는 운영체제의 동작을 이해하기 위한 하드웨어의 동작, 프로그램의 동작을 설명을 할 것이다


## 프로세스의 개념 
프로세스 : a Program in execution
(실행중인 프로그램) 



### 프로세스의 문맥
이때 중요한 것은 프로세스의 문맥(context)
프로그램이 무엇을 시행햇는지(어디까지 수행), 현재 어떤 상태인지를 알 수 잇는 것이 문맥

프로세스는 실행이 되면 프로세스만의 독자적인 주소공간을 만들게 된다(code, data, stack으로 구성)

1) cpu와 관련된 문맥 (주로 regiter가 어디를 가리키고 있나)
그리고 cpu를 할당받으면 프로그램 카운터(레지스터) 가 이프로세스의 코드 어느 부분을 가르키고 있고 그러면 어느순간 instruction을 하나씩 읽어서 cpu안으로 부르고 register 안에 넣고 산술 연산을 한 후 register에 저장하거나 바깥의 메모리에 저장하거나 한다

2) 프로세스의 주소 공간(memory)
그럼 어느 시점에 와있는가를 규명하는 것이 문맥 그럼 프로그램 카운터가 어느 시점을 가지고 있는가, 프로그램 메모리에 무슨 내용을 가지고 잇는가

stack=만일 함수 실행을 했다면 stack에 함수가 쌓여있을 것이다 
어느 내용쌓아놓고 있는가

data= data의 변수 내용을 바꿨다면 지금 무슨 값을 가지고 있는가 
code=register에 어떤 값을 넣고 어떤 값을 실행했는가

3) 프로세스 관련 커널 자료구조
운영체제가 프로세스 관리를 진행한다 
프로세스 하나가 실행될 때 마다 운영체제는 자신의 영역에 PCB(Process Control Block)라는 자료구조를 넣는다
이 때 PCB는 프로세스가 어떤지 평가를 진행한다

    각 프로세스가 자기 코드를 실행할때는 본인의 스택에 함수 호출을 하고 관련 정보를 쌓아놓게 되지만, 운영체제의 코드를 호출할 경우(System call)프로그램 카운터가 프로세스 주소공간을 가리키고 있다가 
    커널을 가리키게 되고 커널의 코드를 실행하게 된다
    커널도 함수들로 이루어져있기 때문에 함수도 stack에 쌓여있게 된다
    커널은 여러 프로세스들이 공유하는 공간이라고 할 수 있다 
    따라서 커널 스택을 프로세스마다 따로 두게 된다 

위와 같은 정보를 두게 되면 프로세스의 문맥을 알 수 있게 된다 
프로세스는 time sharing, multitasking 기반이기 때문에 process context를 알고 있지 못하다면 실행이 중지됐던 그 다음시점부터의 실행을 진행할 수 있다(아니면 처음부터 진행해야한다)


## 프로세스의 상태(process state)

컴퓨터 안에는 cpu가 하나밖에 없다(라고 가정해보자)
1. running
cpu를 잡고 잇는 프로세스는 따라서 하나라고 할 수 있따 실행 상태인 프로세스
2. ready 
cpu를 잡기 위해 대기하고 있는 프로세스( cpu 조건을 제외하고 모든 것 실행메모리에 올라와 있어야한다)
ready 상태인 것들끼리 time sharing을 진행
3. blocked(wait, sleeap)
-io작업 등을 실행하고 있기 때문에 당장 instruction을 실행하기 못하고 있는 상태 (process)

기타 상태
new : 프로세스가 생성 중인 상태
terminated : 프로세스가 종료 중인 상태

new -> ready(in memory) -> running -> (waiting) -> ready -> running -> terminated


cpu는 process 1개 
-> cpu에서 프로세스가 running을 하다가  time interrupt를 당하면 ready queue 맨 뒤로 가게 된다
그러다 disk에서 읽어야한다 그럼 process의 상태는 running 에서 blocked 로 바뀌며 io의 queue로 가게 된다 
io 작업이 다 되면 io controller가 cpu에 interrupt를 걸게 된다 
그리고 cpu 제어권이 운영체제 커널에 넘어가게 된다 그럼 운영체제는 그 프로세스의 메모리 영역에 해당하는 데이터를 넣어주며, process의 상태를 blocked에서 ready 로 바꿔야한다

하드웨어 자원을 요구할 때도 있지만 소프트웨어 공유 데이터를 요구할 때가 있다 
어떤 프로세스가 이미 공유 데이터를 사용하고 있을 때 다른 프로세스가 함께 사용할 수 없기 때문에 resource queue에 줄을 세우는 경우도 있다 

사실 큐는 운영체제 커널이 본인의 데이터 영역에 자료구조로 queue를 만들고 process의 상태를 바꿔가며 ready 상태에 cpu를 주고 block 상태는 cpu를 주지 않고 이런식으로 진행하는 것

### PCB (운영체제 구성)
프로세스를 관리하기 위해 운영체제가 data영역에 두는 정보
1. OS 관리상 필요한 정보
- process state(ready, blocked), process id
- scheduling information(CPU를 주기 위한 우선순위 정보[선착순 아님]) priority 

2. cpu관련 하드웨어 값
process의 문맥을 표시하기 위한 정보들
- cpu에 어떤 register을 넣고 실행하고 있었나

3. 메모리 관련
-code data stack 이 메모리의 어디에 위치해있는가

4. 파일 관련
open 하고 있는 file이 어떤 것이었는 지 등 resource 관련 

### 문맥 교환(Context switch)
cpu는 빠른 자원이기 때문에 짧은 시간 간격으로 cpu를 얻었다 뺐었다 하며 진행하게 된다
이때 cpu를 뺐겼다 다시 얻어서 진행할 때 처음부터 실행하는 것이 아니라 실행하던 부분의 문맥을 기억해서 실행하는 것이 중요하다 

cpu가 사용자 프로세스 하나로부터 또 다른 프로세스로 넘어가는 과정 

cpu를 빼았길 떄 다음 cpu를 얻었을 때 그 문맥부터 실행할 수 있도록 register에 저장돼있던 값을 그 프로세스의 PCB에 저장을 한다(program counter, memory map 또한)

문맥교환 시 save 하는 위치는 pcb는 커널의 process의 data 
위의 pcb위(메모리에서 커널이 관리하는 data 등)

?(여기 잘이해 안됐음)

프로세스가 cpu를 빼았길 때는 이러한 정보를 저장

cpu를 얻을 때 process의 문맥을 pcb에서 찾아서 하드웨어에 다시 복원을 하게 된다 


System call이나 interrupt 발생 시 반드시 context switch가 일어나는 것은 아니다 


사용자 프로세스에서 사용자 프로세스로 넘어가는 과정을 말하는 것이지 interrupt등은 운영체제로 넘어가도록 하는 것이므로 context switch가 아니다

운영체제가 cpu를 다른 프로세스로 넘겨주는 것은 context switch(timer interrupt, I/O 요청 등의 system call)
그런데 운영체제가 시스템 콜 이후에 처리를 하고 다시 발생하기 전 프로세스로 넘겨준다면 그것은 context switch라고 할 수 없다

(물론 context의 일부는 PCB에 저장을 하지만 문맥교환보다 overhead가 더 적음 
cache memory flush : 문맥 교환이 일어날 경우 cache memory 가 다함사라져야함


### 프로세스를 스케쥴링 하기 위한 큐
Job Queue : Ready Queue, Device Queue 등을 모두 포함
Ready Queue
Device Queue : 


pcb에 포인터가 있는 것을 볼 수 있다 
queue는 pcb를 줄세우는 것이다(이 때 포인터 이용)


#### 스케쥴러

스케쥴러 : 각각의 자원 별로 시간을 얼마만큼 잡나..

1. Long-term schedule(job scheduler)
-메모리를 어떤 프로세스에 줄 지를 결정하는 문제 

new -> ready (프로세스)가 될 때 admitted 가 되는데 메모리가 admitted 된다는 것
-메모리를 줄 지 안줄 지 (메모리를 주는 것과 관련된 문제를 다룬다)

프로그램이 실행되면 사실 메모리를 바로 얻어서 실행하는 것이 맞다

degree of multiprogramming(메모리에 동시에 여러 프로그램이 올라가는가)
메모리에 올라가있는 프로세스의 수를 제어하는 것이 long term

메모리에 올라가있는 프로세스의 수를 조절할 필요가 있는데, 메모리에 프로그램이 너무 적게/많게 올라가면 성능이 좋지 않다
근데 time sharing일 때는 장기 스케쥴러가 없다(무조건 ready)
그럼 메모리 조절을 어떻게 하느냐
그건 중기 스케쥴러가 조절해준다

2. Short-term scheduler(Cpu Scheduler / short term scheduler)
milisecond 단위로 스케쥴링이 이루어짐
다음 프로세스에 cpu를 줄 지를 결정하는 것 
3. 중기 스케쥴러(Swapper)
메모리에 너무 많은 프로세스가 올라가있으면, 중기 스케쥴러가 디스크에서 통째로 쫓아내게 된다
(현대의 운영체제)

앞서 말한 process의 상태에 중기 스케쥴러 때문에 추가된 상태가 있다 

Running, Ready, Blocked 외에 
Suspended (stopped): 메모리를 통째로 빼앗긴 상태 
CPU 뿐만 아니라 외부에서 프로세스를 중지시켜놓은 상태 
메모리에서 다 쫓겨나서 통째로 디스크로 swap out 된다
- 사용자도 process를 중지시킬 수 있다(break key) -> 사람이 재개 시켜줘야만 메모리를 사용할 수 있다 

Blocked : 자신이 요청한 event가 만족되면 Ready
Suspended : 외부에서 resume 해주어야 Active (외부에서 정지시켰기 때문에)

running도 두가지 상태가 있다(user running, moniter running/kernel mode running)

i/o 작업은 suspended 작업을 할 수 있따는 것이다 


### Thread 

process 내부의 CPU 수행 단위가 여러개 있는 것 

code/data/stack으로 만들어진 주소공간에 프로세스 하나를 관리하기 위해 운영체제 내부에 PCB를 두게 된다 

PCB의 program counter 가 가르키고 있다 

어떤 동일한 일을 하는 프로세스가 여러개 있다고 하면 그것을 별도의 프로세스로 만들면 메모리 주소 공간이 여러개 만들어질 것이다(메모리 낭비)

-> 그래서 프로세스를 여러개 띄워놓고 싶으면 메모리 공간(주소공간)은 하나만 띄워놓고 현재 각 프로세스마다 다른 부분의 코드를 실행할 수 있도록 하면 된다 

그래서 스레드는 프로세스는 하나만 띄워놓고 현재 CPU가 code의 어느 부분을 실행하고 있는가 즉 프로그램 카운터만 여러개 두는 것이다 

즉 프로세스 하나에 cpu 수행 단위만 여러개 두고 있는 것이 스레드이다

instruction을 실행하려면 현재 어느부분을 실행하고 있는가를 가르키고 있는 프로그램 카운터 필요, 
메모리의 register 값을 setting 을 하고 실행하고 있을 것이다 그래서 cpu마다 현재 register에 어떤 값을 넣고 프로그램 카운터가 코드 어느 부분을 실행하고 있었는가를 별도로 유지한다 

그리고 스레드 하나가 함수 호출을 하면 stack에 함수 호출 정보를 쌓는다 
그런데 cpu 실행 단위가 여러개이면 stack도 여러개로 나눠야할 것이다 

공유할 수 있는 것은 최대한 공유하고(주소공간, 프로세스 상태[프로세스는 하나다!], 프로세스가 사용하는 자원)

다만 별도로 가지고 있는 것은 cpu수행과 관련된 정보(program counter, register, stack)
는 스레드마다 가지게 된다 

스레드 = light weight process 

### 스레드의 장점
하나의 프로세스 안에 스레드 하나가 blocked 상태일 때 다른 스레드가 cpu를 잡고 running을 할 수 있어서 응답시간이 빨라질 수 있다 

ex 
네이버를 본다 <-> 네트워크를 통해 웹페이지를 읽어온다(io) 이 때 오래걸리기때문에 웹 브라우저는 blocked 상태이다 
그럼 사용자 답-답 
그럼 하나의 다른 스레드가 이미 읽어온 텍스트라도 디스플레이라도 해주면 결과를 빨리 볼 수 있기 때문에 답답함이 덜해질 수 있다 


또다른 장점은 같은 일을 하는 작업을 별도의 프로세스로 만들 경우 자원이 낭비된다 (주소공간 새로 만듦 -> 메모리 차지 )


마지막은 이례적인데 cpu가 여러개 달린 경우에 해당 
스레드를 사용하면 병렬성을 높일 수 있다 


----
프로세스는 하나이기 때문에 PCB는 하나만 만들어지는데 프로세스 안에 스레드가 여러개 있게 되면 cpu 수행과 관련된 정보만 각각 스레드마다 별도의 카피를 가지게 된다 
(program counter, regsiter 등등)

이 때 스레드는 프로세스 안에서 독자적으로 가져야하는 정보만 별도로 가지게 된다는 것이다 


1. 응답성 
(아까 설명한 그거)
동기식/비동기식 입출력 차원에서 설명하면 io를 실행시키는 동안에 이 프로세스를 block 시키는 것이 아니라 io가 끝나기 전에 cpu를 얻어서 html 텍스트만 display 해주는 것이다 
즉 읽어온 결과와 무관하게 실행시켜준다(비동기식 입출력)

2. 자원 공유
똑같은 일을 하는 프로그램이 여러개라면 그것을 별도의 프로세스로 실행하는 것 보다는 하나의 프로세스에 cpu수행단위만 여러개 두게 되면 자원을 효율적으로 사용할 수 있다 

3. 경제성
프로세스를 하나 만드는 것은 오버헤드가 크다 
프로세스 안에 스레드를 추가하는 것은 오버헤드가 크지 않다

문맥교환은 오버헤드가 크지만 (cpu 관련 저장, cache memory flush 등 복잡한 일)
스레드간 cpu switching은 간단하다

4. cpu가 여러개인 architecture 인 경우 
프로세서는 하나지만 그 안에 스레드가 여러개 있으면 각각의 
스레드가 서로 다른 cpu에서 병렬적으로 일을 할 수 있다 -> 결과를 빨리 얻을 수 있다 


### 스레드 구현 

1. 커널스레드
스레드가 여러개 있다는 사실을 운영체제 커널이 알고 있다 
그래서 하나의 스레드에서 다른 스레드로 cpu 넘어가는 것도 cpu scheduling 하듯이 넘겨주게 된다

2. 유저스레드
라이브러리를 통해 지원된다 
프로세서 안에 스레드가 여러개가 있다는 것을 운영체제는 모르고 
유저 프로그램이 스스로 라이브러리의 지원을 받아 관리한다 
그래서 유저레벨 스레드는 커널이 모르고 있고, 그냥 일반 프로세스로 보이는데 프로세스 본인이 내부에 cpu 수행단위를 여러개 두고 운영하는 것이기 때문에 구현상 제약점 등이 있을 수 있다 
3. real time 스레드
리얼 타임을 지원해주게 된다 